<!DOCTYPE html>
<html lang="en" class="h-full bg-[#0a0a0a]">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bilbeny's Bookmarks</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script async src="https://platform.twitter.com/widgets.js"></script>
    
    <style>
        [x-cloak] { display: none !important; }
        .content-area { max-width: 680px; }
        .profile-pic img {
            width: 64px;  /* or your original size */
            height: 64px;
            border-radius: 50%;
        }
        .error-details {
            background-color: #fdf2f2;
            border-left: 4px solid #f56565;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }

        .error-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #c53030;
        }

        .memory-warning {
            background-color: #fffaf0;
            border-left: 4px solid #ed8936;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
        }

        .timeout-info {
            background-color: #ebf8ff;
            border-left: 4px solid #4299e1;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
        }
    </style>
    
    {% block head %}
    <script>
    /* Array to store selected categories */
    let selectedCategories = [];

    /* Initialize with category_filter if available */
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof categoryFilter !== 'undefined' && categoryFilter) {
            selectedCategories.push(categoryFilter);
            highlightSelectedCategories();
        }
    });

    /* Toggle category selection */
    function toggleCategory(categoryName) {
        const index = selectedCategories.indexOf(categoryName);
        
        if (index === -1) {
            /* Category not selected, add it */
            selectedCategories.push(categoryName);
        } else {
            /* Category already selected, remove it */
            selectedCategories.splice(index, 1);
        }
        
        /* Update UI to reflect selection */
        highlightSelectedCategories();
        
        // Remove the immediate redirect - let user manually submit
        // This allows multi-selection of categories without triggering search
    }

    /* Highlight selected category buttons */
    function highlightSelectedCategories() {
        document.querySelectorAll('.category-btn').forEach(btn => {
            const category = btn.getAttribute('data-category');
            if (selectedCategories.includes(category)) {
                btn.classList.add('bg-blue-900', 'text-blue-200');
                btn.classList.remove('bg-[#1a1a1a]', 'text-gray-400');
            } else {
                btn.classList.remove('bg-blue-900', 'text-blue-200');
                btn.classList.add('bg-[#1a1a1a]', 'text-gray-400');
            }
        });
    }

    /* Build a URL with selected categories */
    function buildCategoryUrl(baseUrl) {
        if (selectedCategories.length === 0) {
            return baseUrl;
        }
        
        let url = baseUrl + '?';
        selectedCategories.forEach((category, index) => {
            if (index > 0) url += '&';
            url += `categories[]=${encodeURIComponent(category)}`;
        });
        
        return url;
    }

    /* Submit search form with selected categories */
    function submitSearchWithCategories(event) {
        /* Show loading spinner */
        showSearchLoading();
        
        /* Clear previous category inputs */
        document.getElementById('category-inputs').innerHTML = '';
        
        /* Add hidden inputs for each selected category */
        selectedCategories.forEach(category => {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'categories[]';
            input.value = category;
            document.getElementById('category-inputs').appendChild(input);
        });
        
        /* Let the form submit normally */
    }

    // Add a new function to submit a category-only search
    function submitCategoriesOnly() {
        if (selectedCategories.length === 0) {
            // If no categories selected, just go to recent
            window.location.href = '/recent';
            return;
        }
        
        // Construct URL with selected categories
        let url = '/search?';
        selectedCategories.forEach((category, index) => {
            if (index > 0) url += '&';
            url += `categories[]=${encodeURIComponent(category)}`;
        });
        
        // Navigate to the URL
        window.location.href = url;
    }

    /* Show search loading indicator */
    function showSearchLoading() {
        document.getElementById('search-loading').classList.remove('hidden');
    }
    </script>
    {% endblock %}
</head>

<body class="h-full bg-[#0a0a0a] text-white" 
      x-data="{ 
          searchOpen: false, 
          searchByUser: false, 
          uploadModal: false, 
          selectedFile: null,
          uploadStatus: '',
          uploadMessage: '',
          isProcessing: false,
          progressSteps: [],
          /* Add db_error control */
          showDbError: {{ 'true' if db_error and error_message else 'false' }}
      }"
      @file-selected.window="handleFileSelect($event.detail)"
      @update-progress.window="
        progressSteps = $event.detail.steps;
        if ($event.detail.isProcessing !== undefined) {
            isProcessing = $event.detail.isProcessing;
        }
      ">
    <!-- Main content - centered -->
    <div class="min-h-screen flex flex-col items-center px-6">
        <!-- Logo section -->
        <div class="mt-8 mb-6 flex flex-col items-center">
            <a href="/" class="profile-link">
                <div class="profile-pic">
                    <img src="{{ url_for('static', filename='images/profile.jpg') }}" alt="Profile Picture">
                </div>
            </a>
            <h1 class="mt-3 text-xl font-bold text-gray-200">
                Bilbeny's Bookmarks
            </h1>
        </div>

        <!-- Add database error warning here at the top level if needed -->
        {% if db_error and error_message %}
        <div class="alert alert-warning mb-4" role="alert">
            <h4 class="alert-heading"><i class="fas fa-exclamation-triangle"></i> Database Connection Issue</h4>
            <p>{{ error_message|default('We are experiencing database connection issues. Some features may be unavailable.') }}</p>
            <hr>
            <p class="mb-0">Try refreshing the page in a few moments. The basic features are still available, but category management may be limited.</p>
        </div>
        {% endif %}

        <!-- Search and filters container -->
        <div class="content-area w-full">
            <!-- Search bar -->
            <form id="search-form" action="/search" method="get" class="relative" 
                  onsubmit="submitSearchWithCategories(event)">
                <div class="flex">
                    <div class="relative flex-grow">
                        <input 
                            type="text" 
                            name="q"
                            value="{{ query|default('', true) }}"
                            placeholder="Search bookmarks..."
                            class="block w-full bg-[#1a1a1a] border-0 rounded-l-lg py-2.5 pl-10 pr-4 text-sm text-white placeholder-gray-500 focus:ring-1 focus:ring-gray-700"
                        >
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <svg class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                            </svg>
                        </div>
                    </div>
                    <!-- Filter by Category Button -->
                    <button 
                        type="submit"
                        class="px-3 py-2.5 bg-blue-600 text-white rounded-r-lg text-sm hover:bg-blue-700 flex items-center"
                    >
                        <svg class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        Search
                    </button>
                </div>
                <!-- Hidden inputs for categories will be added dynamically -->
                <div id="category-inputs"></div>
            </form>

            <!-- Search loading indicator -->
            <div id="search-loading" class="hidden absolute right-3 top-1/2 transform -translate-y-1/2">
                <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-500"></div>
            </div>

            <!-- Main buttons row -->
            <div class="mt-3 flex flex-wrap items-center justify-between gap-1.5">
                <!-- Left side: Recent and Search by User -->
                <div class="flex gap-1.5">
                    <a href="/recent"
                       class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-gray-400 hover:bg-gray-800 transition-colors">
                        All Bookmarks
                    </a>
                    
                    <button 
                        @click="searchByUser = true"
                        class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-gray-400 hover:bg-gray-800 transition-colors">
                        Search by User
                    </button>
                </div>

                <!-- Right side: Chat and Update DB -->
                <div class="flex gap-1.5">
                    <a href="/chat"
                       class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-blue-400 hover:bg-gray-800 transition-colors flex items-center gap-1">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                  d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z">
                            </path>
                        </svg>
                        Chat
                    </a>

                    {% if is_admin %}
                    <a href="/admin/monitor" 
                       class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-blue-400 hover:bg-gray-800 transition-colors flex items-center gap-1">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        Monitor
                    </a>
                    {% endif %}

                    <a href="/manage/categories" 
                       class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-blue-400 hover:bg-gray-800 transition-colors flex items-center gap-1">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h10m-5-5v10m-7 5h14"></path>
                        </svg>
                        Manage Categories
                    </a>

                    <button 
                        @click="uploadModal = true"
                        class="px-3 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-blue-400 hover:bg-gray-800 transition-colors flex items-center gap-1">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                        </svg>
                        Update DB
                    </button>
                </div>
            </div>

            <!-- Categories row (below main buttons) -->
            <div class="navbar-section mb-4">
                <!-- Categories display - PythonAnywhere specific rendering -->
                <div id="base-categories" class="mt-3 flex flex-wrap gap-1.5">
                    {% for category in categories %}
                        {% if category is mapping %}
                            <a href="/category/{{ category.name }}"
                                data-category="{{ category.name }}"
                                class="category-btn px-2 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-gray-400 hover:bg-gray-800 transition-colors {% if category_filter == category.name %}bg-blue-900 text-blue-200{% endif %}">
                                {{ category.name }} {% if category.count %}({{ category.count }}){% endif %}
                            </a>
                        {% else %}
                            <a href="/category/{{ category }}"
                                data-category="{{ category }}"
                                class="category-btn px-2 py-1 rounded-md text-xs font-medium bg-[#1a1a1a] text-gray-400 hover:bg-gray-800 transition-colors {% if category_filter == category %}bg-blue-900 text-blue-200{% endif %}">
                                {{ category }}
                            </a>
                        {% endif %}
                    {% endfor %}
                </div>
            </div>

            <!-- User Search Modal -->
            <div x-show="searchByUser" 
                 class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center"
                 @click.away="searchByUser = false"
                 x-cloak>
                <div class="bg-[#1a1a1a] p-6 rounded-lg w-96">
                    <h3 class="text-lg font-medium mb-4">Search by Twitter User</h3>
                    <form action="/search" method="get">
                        <input 
                            type="text" 
                            name="user"
                            placeholder="Enter Twitter username..."
                            class="block w-full bg-[#2a2a2a] border-0 rounded-lg py-2 px-4 text-sm text-white placeholder-gray-500 focus:ring-1 focus:ring-gray-700 mb-4"
                        >
                        <div class="flex justify-end">
                            <button 
                                type="button" 
                                @click="searchByUser = false"
                                class="mr-3 px-4 py-2 text-sm text-gray-400 hover:text-white"
                            >
                                Cancel
                            </button>
                            <button 
                                type="submit"
                                class="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm hover:bg-blue-700"
                            >
                                Search
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- New Upload Modal -->
            <div x-show="uploadModal" 
               class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50" 
               x-transition:enter="transition ease-out duration-300"
               x-transition:enter-start="opacity-0"
               x-transition:enter-end="opacity-100"
               x-transition:leave="transition ease-in duration-200"
               x-transition:leave-start="opacity-100"
               x-transition:leave-end="opacity-0">
                <div class="bg-white rounded-lg shadow-xl overflow-hidden max-w-2xl w-full" 
                     @click.away="uploadModal = false">
                    <div class="px-6 py-4 bg-gray-100 border-b flex justify-between items-center">
                        <h3 class="text-lg font-semibold text-gray-800">Upload Twitter Bookmarks</h3>
                        <button @click="uploadModal = false" class="text-gray-500 hover:text-gray-700">
                            <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="p-6">
                        <!-- Instructions -->
                        <div class="bg-blue-50 p-4 rounded-lg mb-6 border border-blue-200">
                            <h4 class="font-semibold text-blue-800 mb-2">Instructions</h4>
                            <p class="text-sm text-blue-700 mb-3">
                                <span class="font-bold">1. Download your Twitter bookmarks:</span><br>
                                - Go to Twitter and request your data archive<br>
                                - Wait for the email and download your archive (ZIP file)<br>
                                - Extract and find the <code class="bg-blue-100 px-1 rounded">bookmarks.js</code> file
                            </p>
                            <p class="text-sm text-blue-700">
                                <span class="font-bold">2. Convert the file:</span><br>
                                - Open <code class="bg-blue-100 px-1 rounded">bookmarks.js</code> in a text editor<br>
                                - Remove the first line: <code class="bg-blue-100 px-1 rounded">window.YTD.bookmarks.part0 = </code><br>
                                - Save as <code class="bg-blue-100 px-1 rounded">bookmarks.json</code>
                            </p>
                        </div>
                        
                        <!-- File Upload Form -->
                        <form id="uploadForm" @submit.prevent="uploadBookmarks" class="space-y-5">
                            <div>
                                <label for="bookmarksFile" class="block text-sm font-medium text-gray-700 mb-1">Select Bookmarks JSON File:</label>
                                <input type="file" id="bookmarksFile" name="file" accept=".json"
                                       class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                <p class="mt-1 text-sm text-gray-500">Upload your prepared bookmarks.json file.</p>
                            </div>
                            
                            <div class="flex items-center">
                                <input id="rebuildVectors" name="rebuildVectors" type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                <label for="rebuildVectors" class="ml-2 block text-sm text-gray-700">Rebuild vector database after processing</label>
                            </div>
                            <p class="text-xs text-gray-500 -mt-4 ml-6">Recommended if searches aren't returning expected results.</p>
                            
                            <!-- Status Section -->
                            <div id="uploadStatusSection" class="hidden mt-4">
                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                    <div id="uploadProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                                </div>
                                <p id="uploadStatusMessage" class="mt-2 text-sm text-center text-gray-600"></p>
                            </div>
                            
                            <!-- Error Messages -->
                            <div id="uploadErrorMsg" class="hidden mt-4 bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded"></div>
                            
                            <!-- Success Message -->
                            <div id="uploadSuccessMsg" class="hidden mt-4 bg-green-50 border border-green-200 text-green-800 px-4 py-3 rounded"></div>
                        </form>
                    </div>
                    
                    <!-- Footer Actions -->
                    <div class="px-6 py-4 bg-gray-50 border-t flex justify-between">
                        <div>
                            <button id="directRebuildButton" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 mr-2">
                                Direct Rebuild Vector Store
                            </button>
                            <button id="processRebuildOnlyButton" class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">
                                Process Rebuild Only
                            </button>
                        </div>
                        <div>
                            <button @click="uploadModal = false" class="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2 mr-2">
                                Cancel
                            </button>
                            <button id="uploadSubmitButton" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                                Upload & Process
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main content area -->
            <main class="mt-6">
                {% block content %}{% endblock %}
            </main>
        </div>
    </div>

    <script>
    // File handling functions
    function handleFileDrop(event) {
        event.preventDefault();
        const file = event.dataTransfer.files[0];
        if (file && file.name.endsWith('.json')) {
            // Debug log
            console.log('File dropped:', file.name);
            // Update Alpine.js state
            this.selectedFile = file.name;
            // Update file input
            document.getElementById('json-file').files = event.dataTransfer.files;
            // Update UI
            document.querySelector('.text-blue-400').textContent = file.name;
        }
    }

    // Add this to debug the form submission
    async function handleUpload(event) {
        event.preventDefault();
        
        const fileInput = document.getElementById('json-file');
        const file = fileInput.files[0];
        
        if (!file) {
            console.log('No file selected');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/upload-bookmarks', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();
            
            if (response.ok) {
                this.uploadStatus = 'success';
                this.uploadMessage = 'File uploaded successfully! Click "Update Database" to process the new data.';
                // Show the Update Database button
                this.$refs.updateDatabaseBtn.classList.remove('hidden');
            } else {
                this.uploadStatus = 'error';
                this.uploadMessage = result.error || 'Error processing file';
            }
        } catch (error) {
            console.error('Upload error:', error);
            this.uploadStatus = 'error';
            this.uploadMessage = 'Error uploading file';
        }
    }

    // Add new function to handle database update
    async function updateDatabase() {
        this.isProcessing = true;
        this.progressSteps = [
            { status: 'processing', message: 'Starting database update...' }
        ];
        
        // Get form data
        const rebuildVector = document.getElementById('rebuild-vector') ? 
            document.getElementById('rebuild-vector').checked : false;
        const resetProgress = document.getElementById('reset-progress') ? 
            document.getElementById('reset-progress').checked : false;

        try {
            // Use the async endpoint instead
            const response = await fetch('/update-database', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rebuild_vector: rebuildVector,
                    reset_progress: resetProgress
                })
            });
            
            const result = await response.json();
            
            if (response.ok) {
                this.progressSteps = [
                    { status: 'done', message: 'Processing started in background' },
                    { status: 'processing', message: 'Update running in background...' }
                ];
                
                // Start polling for updates
                const sessionId = result.session_id;
                this.pollStatus(sessionId);
            } else {
                this.progressSteps.push(
                    { status: 'error', message: result.error || 'Error starting database update' }
                );
                this.isProcessing = false;
            }
        } catch (error) {
            console.error('Database update error:', error);
            this.progressSteps.push(
                { status: 'error', message: 'Error connecting to server' }
            );
            this.isProcessing = false;
        }
    }
    
    // New function to poll status
    async function pollStatus(sessionId) {
        try {
            const response = await fetch(`/update-status?session_id=${sessionId}`);
            const result = await response.json();
            
            if (response.ok) {
                // Update progress UI based on status
                updateProgressFromStatus(result);
                
                // If not complete, continue polling
                if (!result.is_complete) {
                    setTimeout(() => this.pollStatus(sessionId), 2000); // Poll every 2 seconds
                } else {
                    // Process completed
                    this.progressSteps = [
                        { status: 'done', message: 'File validated' },
                        { status: 'done', message: 'SQL database updated' },
                        { status: 'done', message: 'Vector store rebuilt' },
                        { status: 'done', message: result.message || 'Update completed successfully!' }
                    ];
                    
                    // Wait 3 seconds before allowing close
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    this.isProcessing = false;
                }
            } else {
                // Handle error in status check
                this.progressSteps.push(
                    { status: 'error', message: result.error || 'Error checking update status' }
                );
                this.isProcessing = false;
            }
        } catch (error) {
            console.error('Status polling error:', error);
            this.progressSteps.push(
                { status: 'error', message: 'Error connecting to server during status check' }
            );
            this.isProcessing = false;
        }
    }
    
    // Function to update progress UI from status response
    function updateProgressFromStatus(status) {
        // Update step messages based on status
        const progress = status.progress || {};
        const totalProcessed = progress.total_processed || 0;
        const newCount = progress.new_count || 0;
        const updatedCount = progress.updated_count || 0;
        const errors = progress.errors || 0;
        
        this.progressSteps = [
            { status: 'done', message: 'Processing started in background' },
            { status: 'processing', message: `Processing bookmarks: ${totalProcessed} total, ${newCount} new, ${updatedCount} updated, ${errors} errors` }
        ];
        
        if (status.status === 'completed') {
            this.progressSteps.push(
                { status: 'done', message: 'Update completed successfully!' }
            );
        } else if (status.status === 'error') {
            this.progressSteps.push(
                { status: 'error', message: status.message || 'Error during update' }
            );
        }
    }

    function handleFileSelect(event) {
        console.log('handleFileSelect called');
        
        // Handle both direct events and dispatched events
        const file = event.target ? event.target.files[0] : event.detail.target.files[0];
        console.log('File:', file);
        
        if (file && file.name.endsWith('.json')) {
            console.log('Valid JSON file selected:', file.name);
            this.selectedFile = file.name;
            this.uploadStatus = ''; // Reset status for new file
        } else {
            console.log('Invalid or no file selected');
        }
    }

    function handleFileSelectDirect(fileInput) {
        const fileName = fileInput.files[0] ? fileInput.files[0].name : 'No file selected';
        document.getElementById('file-name').textContent = fileName;
        
        // Show upload action buttons if a file was selected
        const uploadActions = document.getElementById('upload-actions');
        uploadActions.style.display = fileInput.files.length > 0 ? 'flex' : 'none';
    }

    function handleUploadDirect() {
        console.log('handleUploadDirect called');
        // Check if a file is selected
        const fileInput = document.getElementById('json-file');
        if (!fileInput.files.length) {
            alert('Please select a file to upload');
            return;
        }
        
        // Reset progress indicators
        const progressSteps = document.getElementById('progress-steps');
        progressSteps.style.display = 'block';
        
        // Reset all steps to pending
        document.querySelectorAll('.progress-icon').forEach(icon => {
            icon.textContent = 'â­•';
        });
        
        // Update upload step to in-progress
        document.getElementById('step-upload').querySelector('.progress-icon').textContent = 'ðŸ”„';
        
        // Create FormData and append the file
        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        
        // Send the file to the server
        fetch('/upload-bookmarks', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Update UI to show success and enable process button
                document.getElementById('step-upload').querySelector('.progress-icon').textContent = 'âœ…';
                document.getElementById('step-validate').querySelector('.progress-icon').textContent = 'âœ…';
                
                // Show the process button and store session ID on it
                const processButton = document.getElementById('process-button');
                processButton.dataset.sessionId = data.session_id;
                processButton.style.display = 'block';
                
                // Hide upload button after successful upload
                document.getElementById('upload-actions').style.display = 'none';
                
                console.log('Upload successful, session ID:', data.session_id);
            } else {
                // Show error
                document.getElementById('step-upload').querySelector('.progress-icon').textContent = 'âŒ';
                alert('Upload failed: ' + (data.error || 'Unknown error'));
                console.error('Upload error:', data);
            }
        })
        .catch(error => {
            document.getElementById('step-upload').querySelector('.progress-icon').textContent = 'âŒ';
            alert('Error uploading file: ' + error.message);
            console.error('Upload error:', error);
        });
    }

    function processBookmarks(buttonElement) {
        // Get session ID from button's data attribute
        const sessionId = buttonElement.dataset.sessionId;
        if (!sessionId) {
            alert('No session ID found. Please try uploading the file again.');
            return;
        }
        
        // Disable the process button to prevent multiple clicks
        buttonElement.disabled = true;
        buttonElement.textContent = 'Processing...';
        
        // Reset progress indicators for processing steps
        document.querySelectorAll('.progress-icon').forEach((icon, index) => {
            // Skip upload and validate steps which are already marked as complete
            if (index > 1) {
                icon.textContent = 'â­•';
            }
        });
        
        // Set finding new bookmarks step to in-progress
        document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'ðŸ”„';
        
        // Send processing request to server
        fetch('/process-bookmarks', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                session_id: sessionId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Processing started:', data);
                
                // Start polling for status updates
                pollProcessStatus(sessionId);
            } else {
                // Show error and enable button for retry
                document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âŒ';
                buttonElement.disabled = false;
                buttonElement.textContent = 'Process File';
                alert('Failed to start processing: ' + (data.error || 'Unknown error'));
                console.error('Processing error:', data);
            }
        })
        .catch(error => {
            document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âŒ';
            buttonElement.disabled = false;
            buttonElement.textContent = 'Process File';
            alert('Error starting processing: ' + error.message);
            console.error('Processing error:', error);
        });
    }
    
    function pollProcessStatus(sessionId) {
        // Poll the status endpoint to check progress
        fetch(`/process-status?session_id=${sessionId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const status = data.status;
                const details = data.details || {};
                
                console.log('Processing status:', status, details);
                
                // Update UI based on status
                updateProcessingUI(status, details);
                
                // Continue polling if still processing
                if (status === 'processing' || status === 'rebuilding_vectors') {
                    setTimeout(() => pollProcessStatus(sessionId), 2000);
                } else if (status === 'completed') {
                    // Processing completed successfully
                    finishProcessingUI(true, details.results || {});
                } else if (status === 'error') {
                    // Processing encountered an error
                    finishProcessingUI(false, details);
                }
            } else {
                // Error checking status
                document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âŒ';
                alert('Error checking processing status: ' + (data.error || 'Unknown error'));
                console.error('Status error:', data);
                
                // Enable process button for retry
                const processButton = document.getElementById('process-button');
                processButton.disabled = false;
                processButton.textContent = 'Process File';
            }
        })
        .catch(error => {
            console.error('Error polling status:', error);
            
            // Retry polling a few times before giving up
            if (window.pollRetryCount === undefined) {
                window.pollRetryCount = 0;
            }
            
            if (window.pollRetryCount < 3) {
                window.pollRetryCount++;
                setTimeout(() => pollProcessStatus(sessionId), 5000);
            } else {
                document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âŒ';
                alert('Error checking processing status: ' + error.message);
                
                // Enable process button for retry
                const processButton = document.getElementById('process-button');
                processButton.disabled = false;
                processButton.textContent = 'Process File';
                
                // Reset retry count
                window.pollRetryCount = 0;
            }
        });
    }

    function updateProcessingUI(status, details) {
        // Update UI based on current processing status
        if (status === 'processing') {
            // Update find-new step with progress information
            const stats = details.stats || {};
            const total = stats.total_bookmarks || 0;
            const processed = stats.processed || 0;
            const percentComplete = total > 0 ? (processed / total * 100) : 0;
            
            const findNewStep = document.getElementById('step-find-new');
            findNewStep.querySelector('.progress-icon').textContent = 'ðŸ”„';
            findNewStep.querySelector('span:last-child').textContent = 
                `Finding new bookmarks... (${processed}/${total}, ${percentComplete.toFixed(1)}%)`;
            
            // Update SQL update step if we've made progress
            if (processed > 0) {
                document.getElementById('step-sql').querySelector('.progress-icon').textContent = 'ðŸ”„';
            }
        } else if (status === 'rebuilding_vectors') {
            // Mark database steps as complete
            document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âœ…';
            document.getElementById('step-sql').querySelector('.progress-icon').textContent = 'âœ…';
            
            // Show vector rebuild in progress
            document.getElementById('step-vectors').querySelector('.progress-icon').textContent = 'ðŸ”„';
        }
    }

    function finishProcessingUI(success, results) {
        // Update UI when processing is finished (either success or error)
        const processButton = document.getElementById('process-button');
        processButton.disabled = false;
        processButton.textContent = 'Process File';
        
        if (success) {
            // Mark all steps as complete
            document.querySelectorAll('.progress-icon').forEach(icon => {
                icon.textContent = 'âœ…';
            });
            
            // Show success message
            const stats = results.stats || {};
            const message = `Processing completed successfully! Added ${stats.new_count || 0} new bookmarks, ` +
                `updated ${stats.updated_count || 0} existing bookmarks.`;
            alert(message);
        } else {
            // Mark appropriate steps as error
            document.getElementById('step-find-new').querySelector('.progress-icon').textContent = 'âŒ';
            
            // Show error message
            alert('Processing failed: ' + (results.error || 'Unknown error'));
            console.error('Processing failed:', results);
        }
        
        // Reset retry count
        window.pollRetryCount = 0;
    }

    function toggleRebuildButton() {
        const rebuildVector = document.getElementById('rebuild-vector');
        const processRebuildBtn = document.getElementById('process-rebuild-btn');
        
        if (rebuildVector.checked) {
            processRebuildBtn.style.display = 'block';
        } else {
            processRebuildBtn.style.display = 'none';
        }
    }

    function processRebuildOnly() {
        // Add immediate console log
        console.log('processRebuildOnly function called');
        alert('Rebuild button clicked - starting process'); // Visual confirmation
        
        // Show progress indicators
        const rebuildBtn = document.getElementById('process-rebuild-btn');
        rebuildBtn.disabled = true;
        rebuildBtn.textContent = 'Processing...';
        
        // Get reset progress option
        const resetProgress = document.getElementById('reset-progress').checked;
        console.log('Reset progress option:', resetProgress);
        
        // Initialize progress steps in Alpine.js
        const progressSteps = [
            { status: 'processing', message: 'Starting vector rebuild...' }
        ];
        
        // Dispatch custom event to update Alpine.js state
        document.dispatchEvent(new CustomEvent('update-progress', {
            detail: { steps: progressSteps, isProcessing: true }
        }));
        console.log('Dispatched update-progress event');
        
        // Call the async-update-database endpoint
        console.log('Sending request to /update-database');
        fetch('/update-database', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                rebuild_vector: true,
                reset_progress: resetProgress
            })
        })
        .then(response => {
            console.log('Response received:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('Response data:', data);
            if (data.success || data.session_id) {
                console.log('Vector rebuild started:', data);
                alert('Rebuild process started successfully!');
                
                // Update progress message
                const updatedSteps = [
                    { status: 'done', message: 'Rebuild process started' },
                    { status: 'processing', message: 'Rebuilding vector database...' }
                ];
                
                // Dispatch custom event to update Alpine.js state
                document.dispatchEvent(new CustomEvent('update-progress', {
                    detail: { steps: updatedSteps }
                }));
                
                // Start polling for status
                if (data.session_id) {
                    pollRebuildStatus(data.session_id);
                }
            } else {
                // Error starting process
                console.error('Error starting rebuild:', data);
                alert('Failed to start rebuild: ' + (data.error || 'Unknown error'));
                
                const errorSteps = [
                    { status: 'error', message: data.error || 'Failed to start rebuild process' }
                ];
                
                // Dispatch custom event to update Alpine.js state
                document.dispatchEvent(new CustomEvent('update-progress', {
                    detail: { steps: errorSteps, isProcessing: false }
                }));
                
                rebuildBtn.disabled = false;
                rebuildBtn.textContent = 'Process Rebuild';
            }
        })
        .catch(error => {
            // Network or other error
            console.error('Fetch error:', error);
            alert('Error connecting to server: ' + error.message);
            
            const errorSteps = [
                { status: 'error', message: 'Error connecting to server: ' + error.message }
            ];
            
            // Dispatch custom event to update Alpine.js state
            document.dispatchEvent(new CustomEvent('update-progress', {
                detail: { steps: errorSteps, isProcessing: false }
            }));
            
            rebuildBtn.disabled = false;
            rebuildBtn.textContent = 'Process Rebuild';
        });
    }

    function pollRebuildStatus(sessionId) {
        // Poll the status endpoint to check progress
        fetch(`/update-status?session_id=${sessionId}`)
        .then(response => response.json())
        .then(data => {
            console.log('Rebuild status:', data);
            
            // Update progress based on status
            updateRebuildProgress(data);
            
            // Continue polling if not complete
            if (data.is_complete === false) {
                setTimeout(() => pollRebuildStatus(sessionId), 2000);
            } else {
                finishRebuild(data.success === true, data);
            }
        })
        .catch(error => {
            console.error('Error polling status:', error);
            
            // Try again a few times
            if (window.pollRetryCount === undefined) {
                window.pollRetryCount = 0;
            }
            
            if (window.pollRetryCount < 3) {
                window.pollRetryCount++;
                setTimeout(() => pollRebuildStatus(sessionId), 5000);
            } else {
                const errorSteps = [
                    { status: 'done', message: 'Rebuild process started' },
                    { status: 'error', message: 'Error checking status: ' + error.message }
                ];
                
                // Dispatch custom event to update Alpine.js state
                document.dispatchEvent(new CustomEvent('update-progress', {
                    detail: { steps: errorSteps, isProcessing: false }
                }));
                
                const rebuildBtn = document.getElementById('process-rebuild-btn');
                rebuildBtn.disabled = false;
                rebuildBtn.textContent = 'Process Rebuild';
                
                window.pollRetryCount = 0;
            }
        });
    }

    function updateRebuildProgress(data) {
        // Update progress messages based on status
        const progress = data.progress || {};
        const message = data.message || 'Processing...';
        
        let updatedSteps = [
            { status: 'done', message: 'Rebuild process started' },
            { 
                status: data.is_complete ? 'done' : 'processing', 
                message: message
            }
        ];
        
        // Add detailed progress if available
        if (progress.total_processed) {
            updatedSteps.push({
                status: 'processing',
                message: `Processed ${progress.total_processed} bookmarks`
            });
        }
        
        // Dispatch custom event to update Alpine.js state
        document.dispatchEvent(new CustomEvent('update-progress', {
            detail: { steps: updatedSteps }
        }));
    }

    function finishRebuild(success, data) {
        const rebuildBtn = document.getElementById('process-rebuild-btn');
        rebuildBtn.disabled = false;
        rebuildBtn.textContent = 'Process Rebuild';
        
        let finalSteps = [
            { status: 'done', message: 'Rebuild process started' }
        ];
        
        if (success) {
            finalSteps.push(
                { status: 'done', message: 'Vector database rebuild completed successfully!' }
            );
        } else {
            finalSteps.push(
                { status: 'error', message: data.error || 'Error during rebuild process' }
            );
        }
        
        // Dispatch custom event to update Alpine.js state
        document.dispatchEvent(new CustomEvent('update-progress', {
            detail: { steps: finalSteps, isProcessing: false }
        }));
        
        // Reset retry count
        window.pollRetryCount = 0;
    }

    // Add direct function for vector rebuild
    function directRebuildCall() {
        alert('Starting direct rebuild API call');

        // Get reset progress option
        const resetProgress = document.getElementById('reset-progress').checked;

        // Make the API call
        fetch('/update-database', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                rebuild_vector: true,
                reset_progress: resetProgress
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('API response:', data);
            if (data.success || data.session_id) {
                alert('Rebuild process started. Check console for details.');
                console.log('Session ID:', data.session_id);
                
                // Optionally start polling
                if (data.session_id) {
                    alert('Will start polling for status updates.');
                    directPollStatus(data.session_id);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('API error:', error);
            alert('Error: ' + error.message);
        });
    }

    // Add direct polling function
    function directPollStatus(sessionId) {
        console.log('Polling status for session:', sessionId);
        
        fetch(`/update-status?session_id=${sessionId}`)
        .then(response => response.json())
        .then(data => {
            console.log('Status update:', data);
            
            // If not complete, poll again
            if (data.is_complete === false) {
                setTimeout(() => directPollStatus(sessionId), 3000);
            } else {
                if (data.success) {
                    alert('Rebuild completed successfully!');
                } else {
                    alert('Rebuild completed with errors: ' + (data.message || 'Unknown error'));
                }
            }
        })
        .catch(error => {
            console.error('Polling error:', error);
            alert('Error checking status: ' + error.message);
        });
    }

    // Upload form handlers
    document.addEventListener('DOMContentLoaded', function() {
        // Define elements
        const uploadForm = document.getElementById('uploadForm');
        const uploadSubmitButton = document.getElementById('uploadSubmitButton');
        const processRebuildOnlyButton = document.getElementById('processRebuildOnlyButton');
        const directRebuildButton = document.getElementById('directRebuildButton');
        const fileInput = document.getElementById('bookmarksFile');
        const rebuildVectorsCheckbox = document.getElementById('rebuildVectors');
        const uploadStatusSection = document.getElementById('uploadStatusSection');
        const uploadProgressBar = document.getElementById('uploadProgressBar');
        const uploadStatusMessage = document.getElementById('uploadStatusMessage');
        const uploadErrorMsg = document.getElementById('uploadErrorMsg');
        const uploadSuccessMsg = document.getElementById('uploadSuccessMsg');
        
        // Function to show status
        function showStatus(message, progress = 0) {
            uploadStatusSection.classList.remove('hidden');
            uploadStatusMessage.textContent = message;
            uploadProgressBar.style.width = `${progress}%`;
        }
        
        // Function to show error
        function showError(message) {
            uploadErrorMsg.classList.remove('hidden');
            uploadErrorMsg.textContent = message;
            uploadStatusSection.classList.add('hidden');
        }
        
        // Function to show success
        function showSuccess(message) {
            uploadSuccessMsg.classList.remove('hidden');
            uploadSuccessMsg.textContent = message;
            uploadStatusSection.classList.add('hidden');
        }
        
        // Function to reset form
        function resetForm() {
            uploadStatusSection.classList.add('hidden');
            uploadErrorMsg.classList.add('hidden');
            uploadSuccessMsg.classList.add('hidden');
            uploadProgressBar.style.width = '0%';
        }
        
        // Function to check update status
        function checkUpdateStatus(sessionId) {
            let attempts = 0;
            const maxAttempts = 60; // 5 minutes (checking every 5 seconds)
            
            const statusChecker = setInterval(() => {
                fetch(`/update-status?session_id=${sessionId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('Status update:', data);
                        
                        if (data.success) {
                            const statusData = data.status;
                            
                            // Update progress bar based on status
                            if (statusData.status === 'processing') {
                                const progress = statusData.progress || {};
                                const total = progress.total_processed || 0;
                                const errors = progress.errors || 0;
                                
                                showStatus(`Processing: ${total} items processed, ${errors} errors`, 50);
                            } else if (statusData.status === 'completed') {
                                showSuccess(statusData.message || 'Processing completed successfully!');
                                clearInterval(statusChecker);
                            } else if (statusData.status === 'error') {
                                showError(statusData.message || 'An error occurred during processing');
                                clearInterval(statusChecker);
                            }
                        } else {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                showError('Timed out waiting for status updates. The process might still be running in the background.');
                                clearInterval(statusChecker);
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error checking status:', error);
                        attempts++;
                        if (attempts >= maxAttempts) {
                            showError('Failed to get status updates after multiple attempts.');
                            clearInterval(statusChecker);
                        }
                    });
            }, 5000); // Check every 5 seconds
        }
        
        // Function to upload file and process bookmarks
        function uploadAndProcess() {
            // Check if file is selected
            if (!fileInput.files || fileInput.files.length === 0) {
                showError('Please select a file to upload');
                return;
            }
            
            const file = fileInput.files[0];
            const formData = new FormData();
            formData.append('file', file);
            
            // Set rebuild vectors flag
            const rebuildVectors = rebuildVectorsCheckbox.checked;
            
            // Reset form
            resetForm();
            
            // Show status
            showStatus('Uploading file...', 10);
            
            // Upload file
            fetch('/upload-bookmarks', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showStatus('File uploaded successfully. Starting processing...', 30);
                    
                    // Start processing
                    return fetch('/update-database', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            rebuild_vector: rebuildVectors
                        })
                    });
                } else {
                    throw new Error(data.error || 'Failed to upload file');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showStatus('Processing started...', 40);
                    
                    // Check status regularly
                    if (data.session_id) {
                        checkUpdateStatus(data.session_id);
                    } else {
                        showSuccess('Processing started. No session ID returned for tracking progress.');
                    }
                } else {
                    throw new Error(data.error || 'Failed to start processing');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showError('Error: ' + error.message);
            });
        }
        
        // Function to process rebuild only
        function processRebuildOnly() {
            // Reset form
            resetForm();
            
            // Show status
            showStatus('Starting vector rebuild...', 10);
            
            console.log('Calling /update-database endpoint to rebuild vectors');
            
            // Call rebuild API
            fetch('/update-database', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rebuild_vector: true
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Rebuild response:', data);
                
                if (data.success) {
                    showStatus('Vector rebuild started...', 30);
                    
                    // Check status regularly
                    if (data.session_id) {
                        checkUpdateStatus(data.session_id);
                    } else {
                        showSuccess('Vector rebuild started. No session ID returned for tracking progress.');
                    }
                } else {
                    throw new Error(data.error || 'Failed to start vector rebuild');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showError('Error: ' + error.message);
            });
        }
        
        // Function for direct vector rebuild call
        function directRebuildCall() {
            // Reset form
            resetForm();
            
            // Show status
            showStatus('Starting direct vector rebuild...', 10);
            
            console.log('Making direct call to /update-database endpoint to rebuild vectors');
            
            // Call rebuild API
            fetch('/update-database', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rebuild_vector: true,
                    direct_call: true
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Direct rebuild response:', data);
                
                if (data.success) {
                    showStatus('Vector rebuild started directly...', 40);
                    
                    // Check status regularly
                    if (data.session_id) {
                        checkUpdateStatus(data.session_id);
                    } else {
                        showSuccess('Vector rebuild started directly. No session ID returned for tracking progress.');
                    }
                } else {
                    throw new Error(data.error || 'Failed to start direct vector rebuild');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showError('Error: ' + error.message);
            });
        }
        
        // Attach event listeners
        if (uploadSubmitButton) {
            uploadSubmitButton.addEventListener('click', uploadAndProcess);
        }
        
        if (processRebuildOnlyButton) {
            processRebuildOnlyButton.addEventListener('click', processRebuildOnly);
        }
        
        if (directRebuildButton) {
            directRebuildButton.addEventListener('click', directRebuildCall);
        }
    });
    </script>
</body>
</html> 